package burp;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jetbrains.annotations.NotNull;
import org.json.*;
public class BurpExtender implements IBurpExtender, IHttpListener {
    private IBurpExtenderCallbacks callbacks;
    private IExtensionHelpers helpers;
    private JPanel ui;
    private HashMap<String, String> savedExtractors = new HashMap<>();
    private ArrayList<Extractor> activatedExtractors = new ArrayList<>();
    private Jsonifiers jsonHelper = new Jsonifiers();
    // test / grep strings
    private static final byte[] GREP_STRING = "Page generated by:".getBytes();
    private static final byte[] INJ_TEST = "|".getBytes();
    private static final byte[] INJ_ERROR = "Unexpected pipe".getBytes();

    //
    // implement IBurpExtender
    //

    @Override
    public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks) {
        // keep a reference to our callbacks object
        this.callbacks = callbacks;
        // obtain an extension helpers object
        helpers = callbacks.getHelpers();

        // set our extension name
        callbacks.setExtensionName("Bubppi");

        callbacks.registerHttpListener(this);
        // register ourselves as a custom scanner check
        ui = new UiRunnable(this);
        SwingUtilities.invokeLater((Runnable) ui);
        callbacks.addSuiteTab((ITab) ui);

    }

    private class UiRunnable extends JPanel implements Runnable, ITab {

        BurpExtender extenderInstance;
        JButton addButton = new JButton("Add");
        JButton clearButton = new JButton("Clear");
        JPanel addedValues;
        JTextField serverAddressField = new JTextField();
        JTextField extractorNameField = new JTextField();


        JTextField extractorEndpointField = new JTextField();
        JTextArea extractorRegexArea = new JTextArea();

        public UiRunnable(BurpExtender instance) {
            this.extenderInstance = instance;
            this.addedValues = populateAdded();
        }

        @Override
        public void run() {

            addButton.addActionListener(extenderInstance::addNewExtractor);
            clearButton.addActionListener(extenderInstance::clearExtractors);
            serverAddressField.setColumns(100);
            extractorNameField.setColumns(100);
            extractorEndpointField.setColumns(100);
            extractorRegexArea.setColumns(20);
            extractorRegexArea.setRows(10);
            this.setLayout(new FlowLayout());
            this.add(serverAddressField);
            this.add(extractorNameField);
            this.add(extractorEndpointField);
            this.add(extractorRegexArea);
            this.add(addButton);
            this.add(clearButton);
            this.add(addedValues);


            callbacks.customizeUiComponent(addButton);
            callbacks.customizeUiComponent(this);

            // add the custom tab to Burp's UI
        }

        public JTextField getServerAddressField() {
            return serverAddressField;
        }

        public JTextField getExtractorEndpointField() {
            return extractorEndpointField;
        }

        public JButton getAddButton() {
            return addButton;
        }

        public JTextField getExtractorNameField() {
            return extractorNameField;
        }

        public JTextArea getExtractorRegexArea() {
            return extractorRegexArea;
        }

        @Override
        public String getTabCaption() {
            return "Bubppi";
        }

        @Override
        public Component getUiComponent() {
            return this;
        }

        public void addNewExtractorValues(JCheckBox value) {
            this.addedValues.add(value);
            this.addedValues.updateUI();
            this.updateUI();
        }


        public void clearAllAdded() {
            addedValues.removeAll();
        }

        public void removeOneAdded(String value) {
            for (Component component : this.addedValues.getComponents()) {
                if (((JCheckBox) component).getText().equals(value)) {
                    addedValues.remove(component);
                }
            }
        }
    }

    private @NotNull
    JPanel populateAdded() {
        JPanel addedList = new JPanel();
        String saved = Objects.requireNonNullElse(
                callbacks.loadExtensionSetting("saved_extractors"), ""
        );

        callbacks.printOutput(saved);
        String[] values = saved.split("~~splitter~~");
        for (String value : values) {
            String[] split = value.split("~~single_splitter~~");
            if (split.length > 1) {
                String name = split[0];
                String regex = split[1];
                callbacks.printOutput(name + "  " + regex);
                this.savedExtractors.put(name, regex);
                JCheckBox activate = new JCheckBox(name);
                activate.addActionListener(this::activateExtractor);
                addedList.add(activate);
            }
        }
        return addedList;
    }

    public void addNewExtractor(ActionEvent actionEvent) {
        String extractorName = ((UiRunnable) ui).getExtractorNameField().getText();
        String extractorRegex = ((UiRunnable) ui).getExtractorRegexArea().getText();
        String extractorEndpoint = ((UiRunnable) ui).getExtractorEndpointField().getText();

        if (savedExtractors.containsKey(extractorName)) {
            try {
                callbacks.getStdout().write(("Value " + extractorName + " Has Already Been Saved With Regex " + extractorRegex).getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            return;


        }
        savedExtractors.put(extractorName, extractorRegex + "~~values_splitter~~" + extractorEndpoint);

        JCheckBox activate = new JCheckBox(extractorName);
        activate.addActionListener(this::activateExtractor);
        ((UiRunnable) ui).addNewExtractorValues(activate);
        updateLocalExtractors();
        updateServer();
    }

    private void updateServer() {
        String server = ((UiRunnable) ui).getServerAddressField().getText();
        callbacks.saveExtensionSetting("server_address", null);
        callbacks.saveExtensionSetting("server_address", server);
    }

    private void updateLocalExtractors() {
        StringJoiner appender = new StringJoiner("~~splitter~~");
        savedExtractors.forEach((key, regex) -> {
            appender.add(new StringJoiner("~~single_splitter~~").add(key).add(regex).toString());

        });
        callbacks.saveExtensionSetting("saved_extractors", null);
        callbacks.saveExtensionSetting("saved_extractors", appender.toString());

    }

    public void clearExtractors() {
        callbacks.saveExtensionSetting("saved_extractors", null);
        savedExtractors.clear();
        activatedExtractors.clear();
        ((UiRunnable) ui).clearAllAdded();
    }

    private void clearExtractors(ActionEvent actionEvent) {
        callbacks.saveExtensionSetting("saved_extractors", null);
        savedExtractors.clear();
        activatedExtractors.clear();
        ((UiRunnable) ui).clearAllAdded();
    }

    private void activateExtractor(ActionEvent actionEvent) {
        JCheckBox eventTarget = (JCheckBox) actionEvent.getSource();
        if (eventTarget.isSelected()) {
            String value = eventTarget.getText();
            savedExtractors.forEach((key, data) -> {
                if (key.equals(value)) {
                    String regex = data.split("~~values_splitter~~")[0];
                    String endpoint = data.split("~~values_splitter~~")[1];
                    callbacks.printOutput("activating: " + regex + " " + endpoint);
                    activatedExtractors.add(new Extractor(regex, endpoint, eventTarget));
                }
            });
        } else {
            activatedExtractors.forEach(extractor -> {
                if (extractor.activator.equals(eventTarget)) activatedExtractors.remove(extractor);
            });
        }
    }

    @Override
    public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {

        if (!messageIsRequest && !messageInfo.getHttpService().getHost().equals("localhost") && activatedExtractors.size() > -1) {
            callbacks.printOutput(String.valueOf(activatedExtractors.size()));
            activatedExtractors.forEach(extractor -> {
                extractor.process(messageInfo);
            });
        }
    }


    class Extractor {
        public final JCheckBox activator;
        private final Pattern REGEX;
        private final String myEndpoint;
        public Extractor(String regex, String endpoint, JCheckBox activator) {
            this.REGEX = Pattern.compile(regex);
            callbacks.printOutput("Pattern works");
            myEndpoint = endpoint;
            this.activator = activator;
        }

        public void process(IHttpRequestResponse messageInfo) {
            String responseBody = generateResponse(messageInfo).toString();
            if (responseBody!= null && responseBody.length() < 3) {
                return;
            }
            sendToServer(responseBody);
        }

        private void sendToServer(String responsBody) {
            String server = callbacks.loadExtensionSetting("server_address") + myEndpoint;
            callbacks.printOutput(server);
            List<String> headers = new ArrayList<>();

            headers.add("POST " + myEndpoint + " HTTP/1.1");
            headers.add("Content-Type: application/json");

                byte[] request = helpers.buildHttpMessage(headers, helpers.stringToBytes(responsBody));
                IHttpService requestService = helpers.buildHttpService("localhost", 8889, false);
                callbacks.printOutput("making request");
                callbacks.printOutput(helpers.bytesToString(request));
                byte[] resp = callbacks.makeHttpRequest(requestService, request).getResponse();
                callbacks.printOutput(helpers.bytesToString(resp));

        }

        public JSONObject generateResponse(IHttpRequestResponse messageInfo) {
            String sData = helpers.bytesToString(messageInfo.getResponse());
            Matcher matches = REGEX.matcher(sData);
            return getJsonBody(matches, messageInfo);
        }

        private JSONObject getJsonBody(Matcher matches, IHttpRequestResponse messageInfo) {
            switch (myEndpoint) {
                case "/dom/dom_xss_sinks":
                    return jsonHelper.jsonifyForDomXssSinks(
                            matches, messageInfo.getHttpService().getHost(),
                            messageInfo.getHttpService().getProtocol() +
                                messageInfo.getHttpService().getHost() + ":" +
                                messageInfo.getHttpService().getPort()
                    )
                    .put("endpoint_id", helpers.base64Encode(myEndpoint));


                case "/dom/much_data":
                    return jsonHelper.jsonifyForMuchData(
                            matches,
                            messageInfo.getHttpService().getProtocol() +
                                    messageInfo.getHttpService().getHost() + ":" +
                                    messageInfo.getHttpService().getPort()
                    ).put("endpoint_id", helpers.base64Encode(myEndpoint));
                default: return new JSONObject("{}");
            }
        }


    }

    class Jsonifiers {
        private JSONObject jsonifyForDomXssSinks(Matcher matches, String hostname, String link_from) {
            JSONObject json = new JSONObject();
            JSONArray data = new JSONArray();
            while (matches.find()) {
                JSONObject sink = new JSONObject();
                sink.put("hostname", hostname);
                sink.put("link_from", link_from);
                sink.put("sink", matches.group());
                data.put(sink);
            }
            if (data.isEmpty()) return new JSONObject("{}");
            json.put("data", data);
            return json;
        }

        private JSONObject jsonifyForMuchData(Matcher matches, String link_from) {
            JSONObject json = new JSONObject();
            JSONArray data = new JSONArray();
            while (matches.find()) {
                JSONObject much_data = new JSONObject();
                Matcher p = Pattern.compile(".?(?:http?|wss|ssh|ftp|file)*://([a-z0-9\\-._~%!$&'()*+,;=]+@)?([a-z0-9\\-._~%]+|\\[[a-z0-9\\-._~%!$&'()*+,;=:]+\\]):([0-9]+)").matcher(matches.group(0));
                int port = p.matches() ? Integer.parseInt(p.group(3)) : (matches.group(2) == "http" ? 80 : 443);
                much_data.put("full_link", Objects.requireNonNullElse(matches.group(0), ""));
                much_data.put("link_only", Objects.requireNonNullElse(matches.group(1), ""));
                much_data.put("protocol", Objects.requireNonNullElse(matches.group(2), ""));
                much_data.put("port", port);
                much_data.put("hostname", Objects.requireNonNullElse(matches.group(3), ""));
                much_data.put("full_path", Objects.requireNonNullElse(matches.group(4), ""));
                much_data.put("path_only", Objects.requireNonNullElse(matches.group(5), ""));
                much_data.put("params", Objects.requireNonNullElse(matches.group(6), ""));
                much_data.put("page_from",  link_from);
                data.put(much_data);
            }
            if (data.isEmpty()) return new JSONObject("{}");
            json.put("data", data);
            return json;
        }
    }

}
