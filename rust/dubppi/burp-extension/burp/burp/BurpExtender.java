package burp;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Objects;
import java.util.StringJoiner;

public class BurpExtender implements IBurpExtender {
    private IBurpExtenderCallbacks callbacks;
    private IExtensionHelpers helpers;
    private JPanel ui;
    private HashMap<String, String> savedExtractors = new HashMap<>();
    private ArrayList<Extractor> activatedExtractors = new ArrayList<>();
    // test / grep strings
    private static final byte[] GREP_STRING = "Page generated by:".getBytes();
    private static final byte[] INJ_TEST = "|".getBytes();
    private static final byte[] INJ_ERROR = "Unexpected pipe".getBytes();

    //
    // implement IBurpExtender
    //

    @Override
    public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks) {
        // keep a reference to our callbacks object
        this.callbacks = callbacks;
        // obtain an extension helpers object
        helpers = callbacks.getHelpers();

        // set our extension name
        callbacks.setExtensionName("Bubppi");

        // register ourselves as a custom scanner check
        ui = new UiRunnable(this);
        SwingUtilities.invokeLater((Runnable) ui);
        callbacks.addSuiteTab((ITab) ui);

    }

    private class UiRunnable extends JPanel implements Runnable, ITab {

        BurpExtender extenderInstance;
        JButton addButton = new JButton("Add");
        JButton clearButton = new JButton("Clear");
        JPanel addedValues;
        JTextField extractorNameField = new JTextField();

        JTextArea extractorRegexArea = new JTextArea();

        public UiRunnable(BurpExtender instance) {
            this.extenderInstance = instance;
            this.addedValues = populateAdded();
        }

        @Override
        public void run() {

            addButton.addActionListener(extenderInstance::addNewExtractor);
            clearButton.addActionListener(extenderInstance::clearExtractors);
            extractorNameField.setColumns(100);
            extractorRegexArea.setColumns(20);
            extractorRegexArea.setRows(10);
            this.setLayout(new FlowLayout());
            this.add(extractorNameField);
            this.add(extractorRegexArea);
            this.add(addButton);
            this.add(clearButton);
            this.add(addedValues);


            callbacks.customizeUiComponent(addButton);
            callbacks.customizeUiComponent(this);

            // add the custom tab to Burp's UI
        }

        public JButton getAddButton() {
            return addButton;
        }

        public JTextField getExtractorNameField() {
            return extractorNameField;
        }

        public JTextArea getExtractorRegexArea() {
            return extractorRegexArea;
        }

        @Override
        public String getTabCaption() {
            return "Bubppi";
        }

        @Override
        public Component getUiComponent() {
            return this;
        }

        public void addNewExtractorValues(JCheckBox value) {

            this.addedValues.add(value);
            this.addedValues.updateUI();
            this.updateUI();
        }

    }

    private JPanel populateAdded() {
        JPanel addedList = new JPanel();
        String saved = Objects.requireNonNullElse(
                callbacks.loadExtensionSetting("saved_extractors"), ""
        );


        String[] values = saved.split("~~splitter~~");
        for (String value : values) {
            String[] split = value.split("~~single_splitter~~");
            if (split.length > 1) {
                String name = split[0];
                String regex = split[1];
                try {
                    callbacks.getStdout().write((name + "  " + regex).getBytes());
                } catch (IOException e) {
                    e.printStackTrace();
                }
                this.savedExtractors.put(name, regex);
                JCheckBox activate = new JCheckBox(name);
                activate.addActionListener(this::activateExtractor);
                addedList.add(activate);
            }
        }
        return addedList;
    }

    public void addNewExtractor(ActionEvent actionEvent) {
        String extractorName = ((UiRunnable) ui).getExtractorNameField().getText();
        String extractorRegex = ((UiRunnable) ui).getExtractorRegexArea().getText();


        if (savedExtractors.containsKey(extractorName)) {
            try {
                callbacks.getStdout().write("Addingff New Valye".getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                callbacks.getStdout().write(("Value " + extractorName + " Has Already Been Saved With Regex " + extractorRegex).getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            return;


        }
        savedExtractors.put(extractorName, extractorRegex);

        JCheckBox activate = new JCheckBox(extractorName);
        activate.addActionListener(this::activateExtractor);
        ((UiRunnable) ui).addNewExtractorValues(activate);
        clearExtractors();
        updateLocalExtractors();
    }

    private void updateLocalExtractors() {
        StringJoiner appender = new StringJoiner("~~splitter~~");
        savedExtractors.forEach((key, regex) -> {
            appender.add(new StringJoiner("~~single_splitter~~").add(key).add(regex).toString());

        });
        callbacks.saveExtensionSetting("saved_extractors", appender.toString());

    }

    public void clearExtractors() {
        callbacks.saveExtensionSetting("saved_extractors", null);
    }

    private void clearExtractors(ActionEvent actionEvent) {
        callbacks.saveExtensionSetting("saved_extractors", null);
    }

    private void activateExtractor(ActionEvent actionEvent) {

    }


    // helper method to search a response for occurrences of a literal match string
    // and return a list of start/end offsets
}

class Extractor {

    private final String REGEX;
    public Extractor(String regex) {
        this.REGEX = regex;
    }

    public String generateResponse(byte[] data) {
        return "";
    }
}