package burp;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jetbrains.annotations.NotNull;
import org.json.*;
public class BurpExtender implements IBurpExtender, IHttpListener {
    private IBurpExtenderCallbacks callbacks;
    private IExtensionHelpers helpers;
    private JPanel ui;
    private HashMap<String, String> savedExtractors = new HashMap<>();
    private ArrayList<Extractor> activatedExtractors = new ArrayList<>();
    private Jsonifiers jsonHelper = new Jsonifiers(this);
    // test / grep strings
    private static final byte[] GREP_STRING = "Page generated by:".getBytes();
    private static final byte[] INJ_TEST = "|".getBytes();
    private static final byte[] INJ_ERROR = "Unexpected pipe".getBytes();

    //
    // implement IBurpExtender
    //

    @Override
    public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks) {
        // keep a reference to our callbacks object
        this.callbacks = callbacks;
        // obtain an extension helpers object
        helpers = callbacks.getHelpers();

        // set our extension name
        callbacks.setExtensionName("Bubppi");

        callbacks.registerHttpListener(this);
        // register ourselves as a custom scanner check
        ui = new UiRunnable(this);
        SwingUtilities.invokeLater((Runnable) ui);
        callbacks.addSuiteTab((ITab) ui);

    }

    private class UiRunnable extends JPanel implements Runnable, ITab {

        BurpExtender extenderInstance;
        JButton addButton = new JButton("Add");
        JButton clearButton = new JButton("Clear");
        JPanel addedValues;
        JTextField serverAddressField = new JTextField();
        JTextField extractorNameField = new JTextField();


        JTextField extractorEndpointField = new JTextField();
        JTextArea extractorRegexArea = new JTextArea();

        public UiRunnable(BurpExtender instance) {
            this.extenderInstance = instance;
            this.addedValues = populateAdded();
        }

        @Override
        public void run() {

            addButton.addActionListener(extenderInstance::addNewExtractor);
            clearButton.addActionListener(extenderInstance::clearExtractors);
            serverAddressField.setColumns(100);
            extractorNameField.setColumns(100);
            extractorEndpointField.setColumns(100);
            extractorRegexArea.setColumns(20);
            extractorRegexArea.setRows(10);
            this.setLayout(new FlowLayout());
            this.add(serverAddressField);
            this.add(extractorNameField);
            this.add(extractorEndpointField);
            this.add(extractorRegexArea);
            this.add(addButton);
            this.add(clearButton);
            this.add(addedValues);


            callbacks.customizeUiComponent(addButton);
            callbacks.customizeUiComponent(this);

            // add the custom tab to Burp's UI
        }

        public JTextField getServerAddressField() {
            return serverAddressField;
        }

        public JTextField getExtractorEndpointField() {
            return extractorEndpointField;
        }

        public JButton getAddButton() {
            return addButton;
        }

        public JTextField getExtractorNameField() {
            return extractorNameField;
        }

        public JTextArea getExtractorRegexArea() {
            return extractorRegexArea;
        }

        @Override
        public String getTabCaption() {
            return "Bubppi";
        }

        @Override
        public Component getUiComponent() {
            return this;
        }

        public void addNewExtractorValues(JCheckBox value) {
            this.addedValues.add(value);
            this.addedValues.updateUI();
            this.updateUI();
        }


        public void clearAllAdded() {
            addedValues.removeAll();
        }

        public void removeOneAdded(String value) {
            for (Component component : this.addedValues.getComponents()) {
                if (((JCheckBox) component).getText().equals(value)) {
                    addedValues.remove(component);
                }
            }
        }
    }

    private @NotNull
    JPanel populateAdded() {
        JPanel addedList = new JPanel();
        String saved = Objects.requireNonNullElse(
                callbacks.loadExtensionSetting("saved_extractors"), ""
        );

        callbacks.printOutput(saved);
        String[] values = saved.split("~~splitter~~");
        for (String value : values) {
            String[] split = value.split("~~single_splitter~~");
            if (split.length > 1) {
                String name = split[0];
                String regex = split[1];
                callbacks.printOutput(name + "  " + regex);
                this.savedExtractors.put(name, regex);
                JCheckBox activate = new JCheckBox(name);
                activate.addActionListener(this::activateExtractor);
                addedList.add(activate);
            }
        }
        return addedList;
    }

    public void addNewExtractor(ActionEvent actionEvent) {
        String extractorName = ((UiRunnable) ui).getExtractorNameField().getText();
        String extractorRegex = ((UiRunnable) ui).getExtractorRegexArea().getText();
        String extractorEndpoint = ((UiRunnable) ui).getExtractorEndpointField().getText();

        if (savedExtractors.containsKey(extractorName)) {
            try {
                callbacks.getStdout().write(("Value " + extractorName + " Has Already Been Saved With Regex " + extractorRegex).getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            return;


        }
        savedExtractors.put(extractorName, extractorRegex + "~~values_splitter~~" + extractorEndpoint);

        JCheckBox activate = new JCheckBox(extractorName);
        activate.addActionListener(this::activateExtractor);
        ((UiRunnable) ui).addNewExtractorValues(activate);
        updateLocalExtractors();
        updateServer();
    }

    private void updateServer() {
        String server = ((UiRunnable) ui).getServerAddressField().getText();
        callbacks.saveExtensionSetting("server_address", null);
        callbacks.saveExtensionSetting("server_address", server);
    }

    private void updateLocalExtractors() {
        StringJoiner appender = new StringJoiner("~~splitter~~");
        savedExtractors.forEach((key, regex) -> {
            appender.add(new StringJoiner("~~single_splitter~~").add(key).add(regex).toString());

        });
        callbacks.saveExtensionSetting("saved_extractors", null);
        callbacks.saveExtensionSetting("saved_extractors", appender.toString());

    }

    public void clearExtractors() {
        callbacks.saveExtensionSetting("saved_extractors", null);
        savedExtractors.clear();
        activatedExtractors.clear();
        ((UiRunnable) ui).clearAllAdded();
    }

    private void clearExtractors(ActionEvent actionEvent) {
        callbacks.saveExtensionSetting("saved_extractors", null);
        savedExtractors.clear();
        activatedExtractors.clear();
        ((UiRunnable) ui).clearAllAdded();
    }

    private void activateExtractor(ActionEvent actionEvent) {
        JCheckBox eventTarget = (JCheckBox) actionEvent.getSource();
        if (eventTarget.isSelected()) {
            String value = eventTarget.getText();
            savedExtractors.forEach((key, data) -> {
                if (key.equals(value)) {
                    String regex = data.split("~~values_splitter~~")[0];
                    String endpoint = data.split("~~values_splitter~~")[1];
                    callbacks.printOutput("activating: " + regex + " " + endpoint);
                    activatedExtractors.add(new Extractor(regex, endpoint, eventTarget));
                }
            });
        } else {
            activatedExtractors.forEach(extractor -> {
                if (extractor.activator.equals(eventTarget)) activatedExtractors.remove(extractor);
            });
        }
    }

    @Override
    public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) {

        if (!messageIsRequest && !messageInfo.getHttpService().getHost().equals("localhost") && activatedExtractors.size() > -1) {
            callbacks.printOutput(String.valueOf(activatedExtractors.size()));
            activatedExtractors.forEach(extractor -> {
                extractor.process(messageInfo);
            });
        }
    }


    class Extractor {
        public final JCheckBox activator;
        private final Pattern REGEX;
        private final String myEndpoint;
        public Extractor(String regex, String endpoint, JCheckBox activator) {
            this.REGEX = Pattern.compile(regex);
            callbacks.printOutput("Pattern works");
            myEndpoint = endpoint;
            this.activator = activator;
        }

        public void process(IHttpRequestResponse messageInfo) {
            String responseBody = generateResponse(messageInfo).toString();
            callbacks.printOutput(responseBody);
            if (responseBody== null || responseBody.length() < 3) {
                return;
            }
            sendToServer(responseBody);
        }

        private void sendToServer(String responsBody) {
            String server = callbacks.loadExtensionSetting("server_address") + myEndpoint;
            callbacks.printOutput(server);
            List<String> headers = new ArrayList<>();

            headers.add("POST " + myEndpoint + " HTTP/1.1");
            headers.add("Content-Type: application/json");

                byte[] request = helpers.buildHttpMessage(headers, helpers.stringToBytes(responsBody));
                IHttpService requestService = helpers.buildHttpService("localhost", 8889, false);
                callbacks.printOutput("making request");
                callbacks.printOutput(helpers.bytesToString(request));
                byte[] resp = callbacks.makeHttpRequest(requestService, request).getResponse();

        }

        public JSONObject generateResponse(IHttpRequestResponse messageInfo) {
            String sData = helpers.bytesToString(messageInfo.getResponse());
            Matcher matches = REGEX.matcher(sData);
            return getJsonBody(matches, messageInfo);
        }

        private JSONObject getJsonBody(Matcher matches, IHttpRequestResponse messageInfo) {
            switch (myEndpoint) {
                case "/dom/dom_xss_sinks":
                    return jsonHelper.jsonifyForDomXssSinks(
                            matches, messageInfo.getHttpService().getHost(),
                            messageInfo.getHttpService().getProtocol() + "://" +
                                    messageInfo.getHttpService().getHost() +
                                    ((messageInfo.getHttpService().getPort() == 80 || messageInfo.getHttpService().getPort() == 443) ? "" : ":" + messageInfo.getHttpService().getPort() )
                    )
                    .put("endpoint_id", helpers.base64Encode(myEndpoint));


                case "/dom/much_data":
                    return jsonHelper.jsonifyForMuchData(
                            matches,
                            messageInfo.getHttpService().getProtocol() + "://" +
                                    messageInfo.getHttpService().getHost() +
                                    ((messageInfo.getHttpService().getPort() == 80 || messageInfo.getHttpService().getPort() == 443) ? "" : ":" + messageInfo.getHttpService().getPort() )

                    ).put("endpoint_id", helpers.base64Encode(myEndpoint));
                case "/dom/own_links":
                    // TODO extract the page that was requested
                    return jsonHelper.jsonifyForOwnLinks(
                            matches,
                            messageInfo.getHttpService().getProtocol(),
                            messageInfo.getHttpService().getPort(),
                            messageInfo.getHttpService().getHost(),
                            messageInfo.getHttpService().getProtocol() + "://" +
                                    messageInfo.getHttpService().getHost() +
                                    ((messageInfo.getHttpService().getPort() == 80 || messageInfo.getHttpService().getPort() == 443) ? "" : ":" + messageInfo.getHttpService().getPort())
                    ).put("endpoint_id", helpers.base64Encode(myEndpoint));
                default: return new JSONObject("{}");
            }
        }


    }

}
